---
title: 刷题
date: 2018-02-16 22:29:38
tags:
---

> 世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？ 

<!--more-->
```C
public int countBitDiff(int m, int n) {
    int re = m^n;
    int num = 0;
    while(re != 0){
        if((re & 1) == 1){
            num++;
        }
        re = re >> 1;
    }
    return num;
}
```

----------------------

> 风口之下，猪都能飞。当今中国股市牛市，真可谓“错过等七年”。 给你一个回顾历史的机会，已知一支股票连续n天的价格走势，以长度为n的整数数组表示，数组中第i个元素（prices[i]）代表该股票第i天的股价。 假设你一开始没有股票，但有至多两次买入1股而后卖出1股的机会，并且买入前一定要先保证手上没有股票。若两次交易机会都放弃，收益为0。 设计算法，计算你能获得的最大收益。 输入数值范围：2<=n<=100,0<=prices[i]<=100 

```
输入例子1:
3,8,5,1,7,8
输出例子1:
12
```
解题：
```
/*
采用动态规划
left[i]标识从0-i最大利润right[i] 从i到end的最大利润
*/
```

--------------------

> **Add Two Numbers**

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
```
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
解决：
```C
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
    
    struct ListNode* empty = (struct ListNode*)malloc(sizeof(struct ListNode));
    empty->val = 0;
    empty->next = NULL;
    
    struct ListNode* br = head;
    int carry = 0;
    
    /* This is the first calculation 
     * so that the logic of the code is
     * is more explicit
     */
    if(l1!= NULL||l2!=NULL){
        if(l1 == NULL){
            l1 = empty;
        }
        if(l2 == NULL){
            l2 = empty;
        }
        br->val = (l1->val + l2->val + carry)%10;
        carry = (l1->val + l2->val + carry)/10;
    }
    l1 = l1->next;
    l2 = l2->next;
    br->next = NULL;

    while(l1!=NULL||l2!=NULL){
        br->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        br = br->next;
        br->next = NULL;
        if(l1 == NULL){
            l1 = empty;
        }
        if(l2 == NULL){
            l2 = empty;
        }
        br->val = (l1->val + l2->val + carry)%10;
        carry = (l1->val + l2->val + carry)/10;
        l1 = l1->next;
        l2 = l2->next;
    }
    
    if(carry>0){
        br->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        br = br->next;
        br->val = carry;
        br->next = NULL;
    }
    return head;
}
```

--------------------

> Longest Substring Without Repeating Characters

Given a string, find the length of the longest substring without repeating characters.
Examples:
Given "abcabcbb", the answer is "abc", which the length is 3.
Given "bbbbb", the answer is "b", with the length of 1.
Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

简单来说就是使用 HashSet 使得 O(n^3) 变为 O(n^2)。(如果单纯使用遍历，会超时)
```Java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int result = 0;
        int i=0,j = 0;
        Set<Character> set = new HashSet<>();
        while(i<n && j<n){
            if(!set.contains(s.charAt(j))){
                set.add(s.charAt(j));
                result = Math.max(result, j-i+1);
                j++;
            }else{
                set.remove(s.charAt(i));
                i++;
            }
        }
        return result;
    }
}
```

C 的版本（出自[这里](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1738/4ms-C-code-in-12-lines)）：
```C
int lengthOfLongestSubstring(char* s)
{
	int len=0;
    char *end=s,*temp;
	char* addressTable[128]={NULL};
	while(*end){
		temp = addressTable[*end];
		addressTable[*end]=end;
		if(temp>=s){
            len=end-s>len?end-s:len;
            s = temp+1;
		}
        end++;
	}
	len=end-s>len?end-s:len;
	return len;
}
```
代码解释：

1. `*end` is the character’s ascii number,
2. and we use the ascii number as the index of addressTable
3. what stored in the addressTable is the character’s address
4. At first, every pointer in addressTable is initialized as NULL
5. and pointer s and end are at the start of the string
6. As the while clause proceeds, the pointer end ‘register’ every character(of that string)'s address into the addressTable of the index(which is the exact ascii number of that character)
7. when end encounters a same ascii number , the if clause will handle this
8. what the if clause will do is recording the length of current substring(specified between s and end, calculated by end-s) and then update s to temp+1
9. temp stores the older same character’s address