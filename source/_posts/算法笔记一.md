---
title: 算法笔记一
date: 2018-02-18 19:09:11
tags:
---

# 排序
## 选择排序 (Selection Sort)
首先, 找到数组中最小的元素, 其次, 将他和数组的第一个元素交换位置. 再次, 再剩下的元素中找到最小的元素, 将他与数组的第二个元素交换位置. 如此往复.
特点:
<!--more-->

- 运行时间与输入无关. 即有序数组的排序与随机排列的数组时间一样的长.
- 数据移动是最小的.

```Java
public class Selection 
{
    public static void sort(Comparable[] a) 
    { // Sort a[] into increasing order. int N = a.length;
    // array length
        for (int i = 0; i < N; i++) 
        { // Exchange a[i] with smallest entry in a[i+1...N). 
        int min = i;
            for (int j = i+1; j < N; j++) 
                if (less(a[j], a[min])) min = j; 
            exch(a, i, min);
        } 
    } // See page 245 for less(), exch(), isSorted(), and main(). 
}
```

## 插入排序 (Insertion Sort)
将元素插入到左边已排序的序列中. 见下图:
![](/images/插入排序.jpg)

```Java
public class Insertion 
{
    public static void sort(Comparable[] a) 
    { // Sort a[] into increasing order. 
        int N = a.length;
        for (int i = 1; i < N; i++) 
        { // Insert a[i] among a[i-1], a[i-2], a[i-3]... .. 
            for (int j = i; j > 0 && less(a[j], a[j-1]); j--) 
                exch(a, j, j-1);
        } 
    } // See page 245 for less(), exch(), isSorted(), and main(). 
}
```

## 希尔排序 (Shell Sort)
它是基于插入排序的. 他的思想是使数组中任意间隔为 h 的都是有序的 (称为 h 有序数组). h 的值由 N/3 减到 1 . 即是插入排序中比较和交换的间隔变为 h。
![](/images/希尔排序.PNG)

```Java
public class Shell 
{
    public static void sort(Comparable[] a) 
    { // Sort a[] into increasing order. 
        int N = a.length; 
        int h = 1;
        while (h < N/3) h = 3*h + 1; // 1, 4, 13, 40, 121, 364, 1093, ... 
        while (h >= 1) 
        { // h-sort the array. 
            for (int i = h; i < N; i++) 
                { // Insert a[i] among a[i-h], a[i-2*h], a[i-3*h]... . 
                 for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) 
                    exch(a, j, j-h);
                } 
            h = h/3; 
        } 
    } // See page 245 for less(), exch(), isSorted(), and main(). 
}
```

## 归并排序 (Merge Sort)
先将 (递归地) 将一个数组分成两半分别排序, 然后将结果归并起来. 归并就是将两部分的第一个数值进行比较, 小的那一个就放进数组的第一个元素中.
特点:

- 长度 N 的数组排序所需的时间和 $N\log N$ 成正比
- 但是它所需要的额外空间和 N 成正比. 但可以通过实现原地归并解决

原地归并的抽象方法:

```Java
public static void merge(Comparable[] a, int lo, int mid, int hi) 
    { // Merge a[lo..mid] with a[mid+1..hi]. 
        int i = lo, j = mid+1;
        for (int k = lo; k <= hi; k++) // Copy a[lo..hi] to aux[lo..hi]. 
            aux[k] = a[k];
        for (int k = lo; k <= hi; k++) // Merge back to a[lo..hi]. 
            if(i > mid)                     a[k] = aux[j++];
            else if (j > hi ) }             a[k] = aux[i++];
            else if (less(aux[j], aux[i]))  a[k] = aux[j++];
            else                            a[k] = aux[i++];
```

自顶向下的归并排序:
```Java
public class Merge 
{
    private static Comparable[] aux;
    public static void sort(Comparable[] a)
    {
        aux = new Comparable[a.length]; // Allocate space just once.
        sort(a, 0, a.length - 1);
    }
    private static void sort(Comparable[] a, int lo, int hi) 
    { // Sort a[lo..hi]. if (hi <= lo) return; 
        int mid = lo + (hi - lo)/2; 
        sort(a, lo, mid);       // Sort left half.
        sort(a, mid+1, hi);     // Sort right half.
        merge(a, lo, mid, hi); // Merge results (code on page 271). 
    } 
}
```
![](/images/归并1.PNG)

自底向上的归并排序:
1个元素的数组先归并成2个元素的数组, 再进行两两归并, 然后四四归并....

```Java
public class MergeBU 
{
    private static Comparable[] aux;    // auxiliary array for merges
    // See page 271 for merge() code.
    public static void sort(Comparable[] a) 
    { // Do lg N passes of pairwise merges. 
        int N = a.length; 
        aux = new Comparable[N];
        for (int sz = 1; sz < N; sz = sz+sz)        // sz: subarray size
            for (int lo = 0; lo < N-sz; lo += sz+sz) // lo: subarray index 
                    merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
    }
}
```
![](/images/归并2.PNG)

## 快速排序 (Quick Sort)
将一个数组切分为两部分, 首先令左边的部分不大于切分元素, 同时右边的数组不小于切分元素, 再将两部分分别排序, 两部分排好后整个数组自然就有序了. 
特点: 原地排序; 排序时间与 $N\log N$成正比. 

```Java
public class Quick 
{
    public static void sort(Comparable[] a) 
    {
        StdRandom.shuffle(a);     //先要打乱元素
        sort(a, 0, a.length - 1); 
    }
    
    private static void sort(Comparable[] a, int lo, int hi) 
    {
        if (hi <= lo) return; 
        int j = partition(a, lo, hi);   // Partition (see page 291). 
        sort(a, lo, j-1);               // Sort left part a[lo .. j-1]. 
        sort(a, j+1, hi);               // Sort right part a[j+1 .. hi].
    } 
}
```
![](/images/快速排序.PNG)

快速排序切分的程序:
```Java
private static int partition(Comparable[] a, int lo, int hi) 
{ // Partition into a[lo..i-1], a[i], a[i+1..hi]. 
    int i = lo, j = hi+1;           // left and right scan indices 
    Comparable v = a[lo];           // partitioning item
    while (true)
    { // Scan right, scan left, check for scan complete, and exchange. 
        while (less(a[++i], v)) if (i == hi) break; 
        while (less(v, a[--j])) if (j == lo) break; 
        if (i >= j) break; 
        exch(a, i, j);
    }
    exch(a, lo, j);         // Put v = a[j] into position
    return j;               // with a[lo..j-1] <= a[j] <= a[j+1..hi].
}
```
![](/images/切分.PNG)

三向切分的快速排序 (设置两个切分元素), 改进性能:
```Java
public class Quick3way 
{
    private static void sort(Comparable[] a, int lo, int hi) 
    { // See page 289 for public sort() that calls this method. 
        if (hi <= lo) return;
        int lt = lo, i = lo+1, gt = hi; 
        Comparable v = a[lo]; 
        while (i <= gt) 
        {
            int cmp = a[i].compareTo(v); 
            if      (cmp < 0)   exch(a, lt++, i++);
            else if (cmp > 0)   exch(a, i, gt--);
            else                i++;
        } // Now a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]. 
        sort(a, lo, lt - 1); 
        sort(a, gt + 1, hi);
    } 
}
```
![](/images/三向切分.PNG)



## 优先队列 (Priority Queues)
功能: 输出最大元素和插入元素. 

泛型优先队列的API: 

| `public class MaxPQ <Key extends Comparable<Key>>` | function |
|:-----|:-----|
| MaxPQ() | create a priority queue |
| MaxPQ(int max)  | create a priority queue of initial capacity max |
| MaxPQ(Key[] a)  | create a priority queue from the keys in a[] |
|void insert(Key v) | insert a key into the priority queue |
|Key max() | return the largest key |
|Key delMax() | return and remove the largest key |
| boolean isEmpty() | is the priority queue empty?|
| int size() | number of keys in the priority queue |

为了展示优先队列的抽象模型的价值, 考虑一下问题: 输入 N 个字符串, 每个字符串都对应着一个整数, 你的任务就是从中找出最大 (或是最小的) M 个整数 (及其关联的字符串)

```Java
//优先队列的用例
public class TopM 
{
    public static void main(String[] args) 
    { // Print the top M lines in the input stream. 
        int M = Integer.parseInt(args[0]);
        MinPQ<Transaction> pq = new MinPQ<Transaction>(M+1); 
        while (StdIn.hasNextLine()) 
        { // Create an entry from the next line and put on the PQ. 
            pq.insert(new Transaction(StdIn.readLine())); 
            if (pq.size() > M) 
                pq.delMin(); // Remove minimum if M+1 entries on the PQ.
        } // Top M entries are on the PQ.
        Stack<Transaction> stack = new Stack<Transaction>(); 
        while (!pq.isEmpty()) stack.push(pq.delMin()); 
        for (Transaction t : stack) StdOut.println(t);
    } 
}
```

从命令行输入一个整数 M 及一系列的字符串, 打印数字最大的 M 行. 
![](/images/优先队列的用例.PNG)

### 堆
数据结构二叉堆能够很好地实现优先队列的基本操作. 在二叉堆的数组中, 每个元素都要保证大于等于另两个特定位置的元素. 相应地, 这些位置的元素又至少大于等于数组中的另两个元素. 这种结构画出后称作二叉树. 
**优先队列的数据存储在数组 pq[1...N] 中, pq[0] 没有使用.**
堆实现的比较和交换方法: 

```Java
private boolean less(int i, int j) 
{ 
    return pq[i].compareTo(pq[j]) < 0; 
}

private void exch(int i, int j) {
    Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; 
}
```

### 由下至上的堆有序化 (上浮)
如果堆的有序状态因为某个节点变得比他的父节点更大而打破, 我们就需要交换他和他的父节点来修复堆 (不断重复交换, 直至堆有序). 
```Java
private void swim(int k) 
{
    while (k > 1 && less(k/2, k)) 
    {
        exch(k/2, k); 
        k = k/2;
    } 
}
```

### 由上至下的堆有序化 (下沉)
```Java
private void sink(int k) 
{
    while (2*k <= N) 
    {
        int j = 2*k;
        if (j < N && less(j, j+1)) j++; 
        if (!less(k, j)) break; 
        exch(k, j); k = j;
}
```
上浮和下沉的应用: 

- 插入元素. 将元素插入到数组尾部, 需要让这个元素上浮到适当的位置.
- 删除最大元素. 从数组顶部删去最大元素实际上就是将顶部的元素删去并将数组的最后一个元素放到顶部, 并让该元素下沉到适当的位置. 

```Java
public class MaxPQ<Key extends Comparable<Key>> 
{
    private Key[] pq;           // heap-ordered complete binary tree
    private int N = 0;          //      in pq[1..N] with pq[0] unused
    
    public MaxPQ(int maxN) 
    { 
        pq = (Key[]) new Comparable[maxN+1]; 
    }
    
    public boolean isEmpty() 
    { 
        return N == 0; 
    }
    
    public int size() 
    {
        return N; 
    }
    
    public void insert(Key v) 
    {
        pq[++N] = v; 
        swim(N);
    }
    public Key delMax() 
    {
        Key max = pq[1];        // Retrieve max key from top.
        exch(1, N--);           // Exchange with last item.
        pq[N+1] = null;         // Avoid loitering.
        sink(1);                // Restore heap property.
        return max; 
    }
    
    // See pages 145-147 for implementations of these helper methods. 
    private boolean less(int i, int j) 
    private void exch(int i, int j) 
    private void swim(int k) 
    private void sink(int k)
}
```

### 堆排序
先是构造一个堆, 再将顶部元素与最后一个元素交换, 再对顶部元素下沉, 如此最大元素就是数组的最后一个元素. 
```Java
public static void sort(Comparable[] a)
{
    int N = a.length;
    for (int k = N/2; k >= 1; k--) 
        sink(a, k, N);              //构造堆, 使得堆有序
    while (N > 1) 
    {
        exch(a, 1, N--); 
        sink(a, 1, N);              //下沉排序
    }
}
```