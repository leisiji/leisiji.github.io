---
title: 算法笔记二
date: 2018-02-23 14:59:30
tags:
---

# 查找
## 符号表 (Symbol Tables)
符号表的主要目的是将一个键和一个值联系起来. 

API:

| `public class ST<Key, Value>` | function |
|---|---|
| ST() | create a symbol table |
| void put(Key key, Value val) | put key-value pair into the table (remove key from table if value is null)|
| Value get(Key key) | value paired with key (null if key is absent) |
| void delete(Key key) | remove key (and its value) from table |
| boolean contains(Key key) | is there a value paired with key? |
| boolean isEmpty() | is the table empty? |
| int size() | number of key-value pairs in the table |
| Iterable<Key> keys() | all the keys in the table |

其中, ST 中不能有空键和空值. 

有序符号表, 保持键的有序性, 定义更多使用的操作: 

| public class ST<Key extends Comparable<Key>, Value> ST() |    |
|---|---|
| ST() | create an ordered symbol table |
| void put(Key key, Value val) | put key-value pair into the table (remove key from table if value is null) |
|Value get(Key key)  | value paired with key (null if key is absent) |
| void delete(Key key) | remove key (and its value) from table  |
| boolean contains(Key key)  | is there a value paired with key?  |
| boolean isEmpty() | is the table empty? |
| int size() | number of key-value pairs |
| Key min() | smallest key |
| Key max() |  largest key |
| Key floor(Key key) | largest key less than or equal to key |
| Key ceiling(Key key) | smallest key greater than or equal to key |
| int rank(Key key) |  number of keys less than key |
| Key select(int k) |  key of rank k |
| void deleteMin() |  delete smallest key |
| void deleteMax() | delete largest key |
| int size(Key lo, Key hi) | number of keys in [lo..hi] |
| Iterable<Key> keys(Key lo, Key hi) | keys in [lo..hi], in sorted order |
| Iterable<Key> keys() | all keys in the table, in sorted order |

### 无序链表的顺序查找
符号表使用的数据结构的一个简单选择是链表. 以下的 SequentialSearchST 用链表实现了符号表的基本 API. 以下没有列出 size(), keys(), delete() 的方法
```Java
public class SequentialSearchST<Key, Value> 
{
    private Node first;
    
    private class Node                       // first node in the linked list
    { // linked-list node 
        Key key; 
        Value val; 
        Node next;
        public Node(Key key, Value val, Node next) 
        {
            this.key = key; 
            this.val = val;
            this.next = next;
        } 
    }
    
    public Value get(Key key) 
    { // Search for key, return associated value. 
        for (Node x = first; x != null; x = x.next) 
            if (key.equals(x.key)) 
                return x.val;                   // search hit
        return null; 
    }

    public void put(Key key, Value val) 
    { // Search for key. Update value if found; grow table if new. 
        for (Node x = first; x != null; x = x.next) 
            if (key.equals(x.key)) 
            { x.val = val; return; }            // Search hit: update val.
        first = new Node(key, val, first);      // Search miss: add new node
    }
}
```

### 有序数组的二分查找
它使用的数据结构是一对平行的数组, 一个存储键一个存储值. 核心方法是 key(), 它返回表中小于给定键的键的数量. 
使用有序数组的原因是二分查找法能够根据数组的索引来标识键可能存在的子数组的大小范围. 
```Java
public class BinarySearchST<Key extends Comparable<Key>, Value> 
{
    private Key[] keys; 
    private Value[] vals;
    private int N;
    
    public BinarySearchST(int capacity) 
    { // See Algorithm 1.1 for standard array-resizing code. 
        keys = (Key[]) new Comparable[capacity];
        vals = (Value[]) new Object[capacity];
    }
    
    public int size() 
    { return N; }
    public Value get(Key key) 
    {
        if (isEmpty()) return null; 
        int i = rank(key);
        if (i < N && keys[i].compareTo(key) == 0)   return vals[i]; 
        else                                        return null; 
    }
    
    public int rank(Key key)  
    {   //二分查找算法, 下面的是循环的实现方法, 也可以用递归来实现. 
        int lo = 0, hi = N-1; 
        while (lo <= hi) 
        {
            int mid = lo + (hi - lo) / 2; 
            int cmp = key.compareTo(keys[mid]); 
            if(cmp < 0)         hi = mid - 1; 
            else if (cmp > 0)   lo = mid + 1; 
            else return mid;
        } 
        return lo;
    }
    
    public void put(Key key, Value val) 
    { // Search for key. Update value if found; grow table if new. 
        int i = rank(key);
        if (i < N && keys[i].compareTo(key) == 0) 
        { vals[i] = val; return; } 
        for (int j = N; j > i; j--) 
        { 
            keys[j] = keys[j-1]; 
            vals[j] = vals[j-1]; 
        } 
        keys[i] = key; 
        vals[i] = val; 
        N++;
    }
    
    public void delete(Key key) 
    // See Exercise 3.1.16 for this method. 
}
```
符号表的其他操作:
```
public Key min() 
    { return keys[0]; }
public Key max() 
    { return keys[N-1]; }
public Key select(int k) 
    { return keys[k]; }
public Key ceiling(Key key) 
{
    int i = rank(key); 
    return keys[i];
}
public Key floor(Key key) 
// See Exercise 3.1.17.
public Key delete(Key key) 
// See Exercise 3.1.16.
public Iterable<Key> keys(Key lo, Key hi) 
{
    Queue<Key> q = new Queue<Key>(); 
    for (int i = rank(lo); i < rank(hi); i++)
        q.enqueue(keys[i]); 
    if (contains(hi))   
        q.enqueue(keys[rank(hi)]); 
    return q;
}
```


## 二叉查找树

特点: 一种能够将链表插入的灵活性和有序数组的高效性结合起来的符号表实现. 
![](/iamges/二叉树.PNG)
基于二叉查找树的符号表: 
```Java
public class BST<Key extends Comparable<Key>, Value> 
{
    private Node root;                      // root of BST
    private class Node 
    {
        private Key key;                    // key
        private Value val;                  // associated value
        private Node left, right;           // links to subtrees
        private int N;                      `以该节点为根的子树中的节点总数`
        
        public Node(Key key, Value val, int N) 
        { this.key = key; this.val = val; this.N = N; }
    }
    
    public int size() 
    { return size(root); }
    
    private int size(Node x) 
    {
        if (x == null)  return 0;
        else            return x.N;
    }
    
// See page 409 for select() and rank().
// See page 411 for delete(), deleteMin(), and deleteMax(). 
// See page 413 for keys().
}
```
get(), put() 方法：
```Java
    public Value get(Key key) 
    { return get(root, key); }
    
    private Value get(Node x, Key key) 
    { // Return value associated with key in the subtree rooted at x; 
     // return null if key not present in subtree rooted at x. 
        if (x == null) return null; 
        int cmp = key.compareTo(x.key); 
        if      (cmp < 0)    return get(x.left, key); 
        else if (cmp > 0)    return get(x.right, key); 
        else return x.val;
    }
    
    public void put(Key key, Value val) 
    { // Search for key. Update value if found; grow table if new. 
        root = put(root, key, val);
    }
    
    private Node put(Node x, Key key, Value val)
    {// Change key’s value to val if key in subtree rooted at x. 
    // Otherwise, add new node to subtree associating key with val. 
        if      (x == null)     return new Node(key, val, 1); 
        int cmp = key.compareTo(x.key); 
        if      (cmp < 0)       x.left = put(x.left, key, val);
        else if (cmp > 0)       x.right = put(x.right, key, val); 
        else x.val = val;
        x.N = size(x.left) + size(x.right) + 1; 
        return x;
    }
```

 min(), max(), floor(), and ceiling() 方法：
```Java
public Key min() 
{
    return min(root).key; 
}

private Node min(Node x) 
{
    if (x.left == null) return x; 
    return min(x.left);
}

public Key floor(Key key) 
{
    Node x = floor(root, key);
    if (x == null) return null; 
    return x.key;
}

private Node floor(Node x, Key key) 
{
    if (x == null)      return null; 
    int cmp = key.compareTo(x.key);
    if (cmp == 0)       return x; 
    if (cmp < 0)        return floor(x.left, key);
    Node t = floor(x.right, key); 
    if (t != null)      return t;
    else                return x;
}
```
select(), rank() 方法：
select 的说明: 对于一棵维护好的树, 节点从左到右 (是指每个节点都要投影到最后一行上), 数值肯定是逐渐增大, 因此一个节点左边的所有子节点数就是它的排名. 
```Java
public Key select(int k) 
{
    return select(root, k).key; 
}

private Node select(Node x, int k) 
{ // 返回排名为 k 的节点
    if (x == null)  return null; 
    int t = size(x.left);
    if (t > k)      return select(x.left, k);
    else if (t < k) return select(x.right, k-t-1);
    else            return x;
}
---------------------------------------------------
public int rank(Key key) 
{ 
    return rank(key, root); 
}

private int rank(Key key, Node x) 
{ // 返回以 x 为根节点的子树中小于 x.key 的键的数量
    if (x == null)      return 0; 
    int cmp = key.compareTo(x.key); 
    if(cmp < 0)         return rank(key, x.left);
    else if (cmp > 0)   return 1 + size(x.left) + rank(key, x.right);
    else                return size(x.left);
}
```
deletion in BSTs
```Java
public void deleteMin() 
{
    root = deleteMin(root);
}

private Node deleteMin(Node x) 
{ // 不断检索左子节点, 直到遇到空节点, 最后返回的是根节点, 方便后续的 delete() 操作
    if (x.left == null) return x.right; 
    x.left = deleteMin(x.left);
    x.N = size(x.left) + size(x.right) + 1; 
    return x;
}
---------------------------------------------

public void delete(Key key)
{ root = delete(root, key); }

private Node delete(Node x, Key key) 
{
    if (x == null)      return null; 
    int cmp = key.compareTo(x.key); 
    if (cmp < 0)        x.left = delete(x.left, key); 
    else if (cmp > 0)   x.right = delete(x.right, key); 
    else 
    {
        if (x.right == null)    return x.left;
        if (x.left == null)     return x.right; 
        Node t = x;
        x = min(t.right); // See page 407. 
        x.right = deleteMin(t.right);   
        x.left = t.left;                // 要求删除节点的左边未发生变化
    }
    x.N = size(x.left) + size(x.right) + 1; 
    return x;
}
``` 
![](/images/二叉查找树.jpg)

按顺序打印二叉树的所有键 :
```Java
private void print(Node x) 
{
    if (x == null) return; 
    print(x.left);
    StdOut.println(x.key);
    print(x.right);
}
```

范围查找 (Range searching): 
```Java
public Iterable<Key> keys() 
{ return keys(min(), max()); }

public Iterable<Key> keys(Key lo, Key hi) 
{
    Queue<Key> queue = new Queue<Key>(); 
    keys(root, queue, lo, hi); 
    return queue;
}

private void keys(Node x, Queue<Key> queue, Key lo, Key hi) 
{
    if (x == null)                  return;
    int cmplo = lo.compareTo(x.key); 
    int cmphi = hi.compareTo(x.key); 
    if (cmplo < 0)                  keys(x.left, queue, lo, hi); 
    if (cmplo <= 0 && cmphi >= 0)   queue.enqueue(x.key); 
    if (cmphi > 0)                  keys(x.right, queue, lo, hi);
}
```

## 平衡查找树
2-3 查找树, 2-节点 (含有一个键和两条链接), 3-节点 (含有两个键和三条链接)
3-节点: 左连接指向的键小于该 3-节点, 中间链接位于 3-节点的两个键之间, 右链接就不必说明了. 
![](/images/平衡查找树1.jpg)

树的操作:

1. 查找, 比较的简单, 不做叙述
2. 向二节点插入新键, 将这个二节点转换为三节点 (这个节点由一个键变为了两个键)
3. **向一棵只含有一个 3-节点的树中插入新键**, 先将键存入节点, 使之称为 4-节点, 再将它分解为一棵含有 3 个 2-节点组成的 2-3 树. 过程如下面的第一幅图
4. **向一个父节点为 2-节点的 3-节点中插入新键**, 先将键存入节点, 使之称为 4-节点, 再将中间的键移动到 2-节点的父节点中, 使之形成 3-节点, 过程如下图二
5. **向一个父节点为 3-节点的 3-节点中插入新键**, 先将键存入节点, 使之称为 4-节点, 再将中间的键移动到 3-节点的父节点中, 如此父节点的中间的键移动到 2-节点的再上一级的父节点中. 
6. **分解根节点**, 如果从插入点到根节点的路径上全部是 3-节点, 根节点则会变成一个临时的 4-节点, 那就一直将中间键向上传直到根节点, 最后将根节点分解.

树的变换都是局部变换, 局部变换不会改变树的有序性和平衡性

![](/images/平衡查找树2_1.jpg) ![](/images/平衡查找树2_2.jpg)
![](/images/平衡查找树3_1.jpg) ![](/images/平衡查找树3_2.jpg)

## 红黑二叉查找树
实现 2-3 平衡树的一种数据结构


**替换3-节点**
红黑树的基本思想是用标准的二叉查找树和一些额外的信息来表示 2-3 树. 
`红链接`是将两个 2-节点连接起来构成一个三节点, 图上表示就是将红链接表示成水平的
`黑链接`是 2-3 树中的普通链接. 
一些性质:

- 红链接均是左连接;
- 没有一个节点同时和两个红链接相连
- 该树是完美黑色平衡的, 即任意空连接到根节点的路径上的黑链接数量相同 (将红链接画平)

颜色表示的代码实现:
**这里的颜色是指指向自己的链接, 因为指向子节点有两条链接**
```Java
private static final boolean RED = true; 
private static final boolean BLACK = false;

private class Node 
{
    Key key;            // key
    Value val;          // associated data
    Node left, right;   // subtrees 
    int N;              // # nodes in this subtree
    boolean color;      // color of link from parent to this node
    
    Node(Key key, Value val, int N, boolean color) 
    {
        this.key = key; 
        this.val = val; 
        this.N = N; 
        this.color = color; 
    }
}

private boolean isRed(Node x) 
{
    if (x == null) return false; 
    return x.color == RED;
}
```


**旋转**
旋转后链接的颜色不会发生改变, 旋转的变化就是两个节点的高低层级发生变化
在我们的某些操作可能会出现红色右链接或者两条红链接, 因此需要旋转修复.
如果有一条红色右链接, 进行左旋转, 红链接两个键中间的链接链接变换, 其他不用发生变化;
如果有两条连续的红链接 (不是同时指向子节点的, 而是连续的父子的直线), 就要右旋转: 
```Java
Node rotateLeft(Node h) 
{
    Node x = h.right; # 由于只传入了 h 一个值, 必须先赋值 x
    h.right = x.left; 
    x.left = h;
    x.color = h.color; 
    h.color = RED; 
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x; 
}

Node rotateRight(Node h)
{
    Node x = h.left; 
    h.left = x.right; 
    x.right = h;
    x.color = h.color;
    h.color = RED; 
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}
```

![](/images/旋转1.jpg) ![](/iamges/旋转2.jpg)


**在旋转后的重置父节点的链接** :
无论是左还是右旋转, 都会返回一条链接. 
`h = rotateleft(h) or rotateright(h)` 修正


**向 2-节点插入新键, 向树底部的 2-节点插入新键**
**在插入键时的初始化的颜色是红色**

![](/images/插入1.jpg) ![](/images/插入2.jpg)


**向一棵双键树 (即一个 3-节点) 中插入新键** :
有三种情况: 新键介于树的两个键之间, 大于或者小于右键左键 (`打竖分类`)
![](/images/插入3.jpg)


**颜色转换**
两个子节点由红色变为黑色, 同时父节点也要从黑变成红色 : `flipColors()`
```Java
void flipColors(Node h) 
{
    h.color = RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}
```

![](/images/颜色转换.jpg)


**向树底部的 3-节点插入新键, 将红链接在树中向上传递** :

![](/images/底部插入1.jpg)  ![](/images/底部插入2.jpg)


```Java
public class RedBlackBST<Key extends Comparable<Key>, Value> 
{
    private Node root; 
    private class Node      // BST node with color bit (see page 433)
    
    private boolean isRed(Node h)   // See page 433.
    private Node rotateLeft(Node h) // See page 434. 
    private Node rotateRight(Node h) // See page 434. 
    private void flipColors(Node h) // See page 436.
    
    private int size() // See page 398.
    
    public void put(Key key, Value val)
    { // Search for key. Update value if found; grow table if new. 
        root = put(root, key, val);
        root.color = BLACK;
    }
    
    private Node put(Node h, Key key, Value val) 
    {
        if (h == null) // Do standard insert, with red link to parent. 
            return new Node(key, val, 1, RED);
            
        int cmp = key.compareTo(h.key); 
        if(cmp < 0)         h.left = put(h.left, key, val); 
        else if (cmp > 0)   h.right = put(h.right, key, val); 
        else h.val = val;
        
        if (isRed(h.right) && !isRed(h.left))       h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left))    h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right))        flipColors(h);
        h.N = size(h.left) + size(h.right) + 1; 
        return h;
    }
}
```

## 散列表 (Hash Tables)
**维基上的通俗解释**: 通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。
一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x) 的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。


用算术操作将键转换为数组的索引来访问数组中的键值对.
散列表是在时间和空间上做出权衡的经典例子. 如果没有内存限制, 我们可以之间将键作为一个超大的数组, 查找操作只需访问一次内存就可以; 如果没有时间限制, 我们可以用无序数组进行顺序查找, 这样只需很少的内存.
使用哈希查找有两个步骤:

1. 使用哈希函数将被查找的键转换为数组的索引。
2. 处理哈希碰撞冲突。拉链法和线性探测法。


**散列函数**
对于不同类型的键都需要一个与之对应的散列函数 (int, string)

- 正整数: 除留余数法, (k % M) 将键分散在 0 到 M-1 的范围内. 
- 浮点数: 将键表示为二进制数再使用除留余数法


将 `hashCode()` 的值转化为一个数组索引, 因为我们需要的是数组的索引而不是一个 32 位的整数, 以下代码就会将符号位屏蔽 (将一个 32 位的整数变为一个 31 位非负整数)
```Java
private int hash(Key x) 
{ return (x.hashCode() & 0x7fffffff) % M; }
```
自定义的 `hashCode()` 方法: 
```Java
public class Transaction 
{
    ...
    private final String who; 
    private final Date when; 
    private final double amount;
    
    public int hashCode() 
    {
        int hash = 17;
        hash = 31 * hash + who.hashCode(); 
        hash = 31 * hash + when.hashCode(); 
        hash = 31 * hash + ((Double) amount).hashCode(); 
        return hash; 
    } 
    ... 
}
```


**基于拉链法的散列表**
一个散列函数能将键转化为数组索引; 散列算法的第二步是碰撞处理, 也就是处理多个键的散列值 (`hash()`值, 不是 `hashCode()`的值, 因此只有 $0 \sim M-1$ 个值). 一种直接的办法就是将大小为 M 的数组中的每个元素都指向一条链表, 链表中的每个节点都存储了散列值为该元素的索引的键值对.
![](/images/拉链法的散列表.jpg)

以下为基于拉链表 (SeparateChainingHashST) 的散列表: 
```Java
public class SeparateChainingHashST<Key, Value>
{
    private int N;          // number of key-value pairs
    private int M;          // hash table size
    private SequentialSearchST<Key, Value>[] st; // 存放链表对象的数组
    
    public SeparateChainingHashST() 
    { this(997); }
    
    public SeparateChainingHashST(int M) 
    { // Create M linked lists. 
        this.M = M;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M]; 
        for (int i = 0; i < M; i++) 
            st[i] = new SequentialSearchST();
    }
    
    private int hash(Key key) 
    { return (key.hashCode() & 0x7fffffff) % M; }
    
    public Value get(Key key) 
    { return (Value) st[hash(key)].get(key); }
    
    public void put(Key key, Value val) 
    { st[hash(key)].put(key, val); }
    
    public Iterable<Key> keys() // See Exercise 3.4.19.
}
```
在实现拉链法的时候, 我们的目标是选择适当的数组大小 M, 既不会因为空链表而浪费内存, 也不会因为链表过长而在查找上浪费时间


**基于线性探测法的散列表**
linear probing, 用大小为 M 的数组保存 N 个键值对, 其中 M>N. 具体过程就是: 用散列函数找到键在数组中的索引, 如果该索引 i 处没有元素则可以将该键和值增加进数组, 如果早已存在键和值, 则查找 i+1, i+2... 直到该处没有键和值. (查找就是直到与键相等的索引或者空元素结束)

```Java
public class LinearProbingHashST<Key, Value> 
{
    private int N;          // number of key-value pairs in the table
    private int M = 16;     // size of linear-probing table
    private Key[] keys;     // the keys
    private Value[] vals;   // the values
    
    public LinearProbingHashST() 
    {
        keys = (Key[]) new Object[M]; 
        vals = (Value[]) new Object[M];
    }
    
    private int hash(Key key) 
    { return (key.hashCode() & 0x7fffffff) % M; }
    
    private void resize() // See page 474.
    
    public void put(Key key, Value val) 
    {
        if (N >= M/2)   resize(2*M); // 将 M 加倍
        int i;
        for (i = hash(key); keys[i] != null; i = (i + 1) % M) 
            if (keys[i].equals(key)) { vals[i] = val; return; }
        keys[i] = key;
        vals[i] = val;
        N++;
    }
    
    public Value get(Key key) 
    {
        for (int i = hash(key); keys[i] != null;i = (i + 1) % M) 
            if (keys[i].equals(key)) 
                return vals[i];
        return null;
    }
}
```
删除操作: 将该位置的元素设置为 null 是不行的, 因为这样会导致之后的元素无法查找 (拥有相同的 `hash()` 的元素无法被查找);
因此我们需要将删除键的右侧所有连续的键重新排列, 即是将一条右边是空的键向左移动一位.
```Java
public void delete(Key key) 
{
    if (!contains(key)) return; 
    int i = hash(key);
    while (!key.equals(keys[i]))
        i = (i + 1) % M; 
    keys[i] = null; 
    vals[i] = null; 
    i = (i + 1) % M;
    while (keys[i] != null)
    {
        Key keyToRedo = keys[i]; 
        Value valToRedo = vals[i]; 
        keys[i] = null; 
        vals[i] = null; 
        N--;
        put(keyToRedo, valToRedo); 
        i = (i + 1) % M;
    }
    N--;
    if (N > 0 N == M/8) resize(M/2);
}
```
调整数组大小
```Java
private void resize(int cap) 
{
    LinearProbingHashST<Key, Value> t; 
    t = new LinearProbingHashST<Key, Value>(cap); 
    for (int i = 0; i < M; i++) 
        if (keys[i] != null)
            t.put(keys[i], vals[i]);
    keys = t.keys; 
    vals = t.vals; 
    M  = t.M;
}
```